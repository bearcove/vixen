//! Input tracking for Rust compilation nodes
//!
//! This module defines the types for tracking which files were read during
//! a Rust compilation, enabling accurate cache keys and dynamic graph expansion.
//!
//! ## Two-phase approach
//!
//! 1. **Bootstrap (pre-rustc)**: Use module_scanner to build a `SeedInputSet`
//!    for cache lookups before running rustc.
//! 2. **Finalize (post-rustc)**: Parse rustc's dep-info to get the
//!    `FinalInputSet` - the authoritative record of what was actually read.
//!
//! ## Input classification
//!
//! Files are classified into categories based on their location:
//! - `WorkspaceFile`: Under the workspace root
//! - `GeneratedFile`: Produced by a prior node in the graph
//! - `DeclaredExternal`: Explicitly declared external inputs (contract)
//! - `ToolchainFile`: Part of the Rust toolchain/sysroot

use camino::{Utf8Path, Utf8PathBuf};
use facet::Facet;
use std::collections::HashSet;

/// Input tracking for a Rust compilation node
///
/// This tracks both the snapshot we send to execd and the observed inputs
/// that rustc actually used (from dep-info).
#[derive(Debug, Clone, PartialEq, Eq, Facet)]
pub struct InputRecords {
    /// Snapshot inputs: the maximalist superset we sent to execd
    /// This is intentionally over-inclusive to avoid missing files.
    pub snapshot_inputs: InputSet,

    /// Observed inputs: what dep-info says rustc actually read
    /// This is authoritative and used for cache keys.
    /// None until we've parsed dep-info.
    pub observed_inputs: Option<InputSet>,
}

impl InputRecords {
    pub fn new(snapshot: InputSet) -> Self {
        Self {
            snapshot_inputs: snapshot,
            observed_inputs: None,
        }
    }

    /// Set the observed inputs from parsed dep-info
    pub fn set_observed(&mut self, observed: InputSet) {
        self.observed_inputs = Some(observed);
    }

    /// Check if observed inputs are available
    pub fn has_observed(&self) -> bool {
        self.observed_inputs.is_some()
    }
}

/// A set of input files for a Rust compilation node
#[derive(Debug, Clone, PartialEq, Eq, Facet)]
pub struct InputSet {
    /// Files under the workspace root
    pub workspace_files: Vec<WorkspaceFile>,
    /// Files generated by prior build nodes
    pub generated_files: Vec<GeneratedFile>,
    /// Explicitly declared external inputs
    pub declared_external: Vec<DeclaredExternal>,
    /// Toolchain files (sysroot, etc.) - usually excluded from input closure
    /// but tracked for diagnostics
    pub toolchain_files: Vec<ToolchainFile>,
}

impl InputSet {
    pub fn new() -> Self {
        Self {
            workspace_files: Vec::new(),
            generated_files: Vec::new(),
            declared_external: Vec::new(),
            toolchain_files: Vec::new(),
        }
    }

    /// Add a workspace-relative file
    pub fn add_workspace_file(&mut self, rel_path: String) {
        self.workspace_files.push(WorkspaceFile { rel_path });
    }

    /// Add a generated file by its producing node/blob ID
    pub fn add_generated_file(&mut self, id: String) {
        self.generated_files.push(GeneratedFile { id });
    }

    /// Add a declared external input
    pub fn add_declared_external(&mut self, path: String) {
        self.declared_external.push(DeclaredExternal { path });
    }

    /// Add a toolchain file
    pub fn add_toolchain_file(&mut self, path: String) {
        self.toolchain_files.push(ToolchainFile { path });
    }

    /// Deduplicate all input lists
    pub fn dedup(&mut self) {
        let mut seen = HashSet::new();
        self.workspace_files
            .retain(|f| seen.insert(f.rel_path.clone()));

        let mut seen = HashSet::new();
        self.generated_files.retain(|f| seen.insert(f.id.clone()));

        let mut seen = HashSet::new();
        self.declared_external
            .retain(|f| seen.insert(f.path.clone()));

        let mut seen = HashSet::new();
        self.toolchain_files.retain(|f| seen.insert(f.path.clone()));
    }

    /// Sort all input lists for determinism
    pub fn sort(&mut self) {
        self.workspace_files
            .sort_by(|a, b| a.rel_path.cmp(&b.rel_path));
        self.generated_files.sort_by(|a, b| a.id.cmp(&b.id));
        self.declared_external.sort_by(|a, b| a.path.cmp(&b.path));
        self.toolchain_files.sort_by(|a, b| a.path.cmp(&b.path));
    }

    /// Normalize: dedup and sort
    pub fn normalize(&mut self) {
        self.dedup();
        self.sort();
    }
}

impl Default for InputSet {
    fn default() -> Self {
        Self::new()
    }
}

/// A file under the workspace root
#[derive(Debug, Clone, PartialEq, Eq, Hash, Facet)]
pub struct WorkspaceFile {
    /// Workspace-relative path (e.g., "src/lib.rs")
    pub rel_path: String,
}

/// A file generated by a prior build node
#[derive(Debug, Clone, PartialEq, Eq, Hash, Facet)]
pub struct GeneratedFile {
    /// ID of the producing node or CAS blob
    /// (exact format TBD - could be node output ID, CAS hash, etc.)
    pub id: String,
}

/// An explicitly declared external input (part of the "extra inputs contract")
#[derive(Debug, Clone, PartialEq, Eq, Hash, Facet)]
pub struct DeclaredExternal {
    /// Absolute or workspace-relative path
    pub path: String,
}

/// A toolchain file (part of sysroot, rustlib, etc.)
#[derive(Debug, Clone, PartialEq, Eq, Hash, Facet)]
pub struct ToolchainFile {
    /// Path to the toolchain file
    /// (usually absolute, but could be normalized)
    pub path: String,
}

/// Classification result for a dependency path
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PathClassification {
    /// File is under workspace root (workspace-relative path)
    Workspace(String),
    /// File is a generated output (ID)
    Generated(String),
    /// File is part of toolchain (absolute path)
    Toolchain(String),
    /// File is external/unknown (absolute path, may require declaration)
    External(String),
}

/// Validation error for inputs outside workspace
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OutsideWorkspaceError {
    /// A dependency was found outside workspace and not in any allowlist
    UnallowedExternalDep {
        path: String,
        /// Suggested fix: add to toolchain allowlist, generated roots, or explicit contract
        suggestion: String,
    },
}

/// Error when dep-info references workspace files not in snapshot
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SnapshotIncompleteError {
    /// Workspace-relative paths that were missing from snapshot
    pub missing_files: Vec<String>,
}

impl SnapshotIncompleteError {
    pub fn new(missing_files: Vec<String>) -> Self {
        Self { missing_files }
    }
}

/// Error when non-.rs files are used but not declared
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UndeclaredExtraInputsError {
    /// Workspace-relative paths to non-.rs files that need to be declared
    pub undeclared_files: Vec<String>,
}

impl UndeclaredExtraInputsError {
    pub fn new(undeclared_files: Vec<String>) -> Self {
        Self { undeclared_files }
    }
}

/// Check if observed inputs are all covered by snapshot
///
/// This detects cases where rustc read workspace files that weren't included
/// in the snapshot (e.g., via include_str!(), #[path="..."], etc.).
///
/// # Arguments
///
/// * `observed_inputs` - The InputSet from parsing dep-info
/// * `snapshot_files` - Set of workspace-relative paths that were in the snapshot
///
/// # Returns
///
/// Ok(()) if all observed workspace files were in snapshot
/// Err(SnapshotIncompleteError) with the list of missing files otherwise
pub fn validate_snapshot_complete(
    observed_inputs: &InputSet,
    snapshot_files: &HashSet<String>,
) -> Result<(), SnapshotIncompleteError> {
    let mut missing = Vec::new();

    for workspace_file in &observed_inputs.workspace_files {
        if !snapshot_files.contains(&workspace_file.rel_path) {
            missing.push(workspace_file.rel_path.clone());
        }
    }

    if missing.is_empty() {
        Ok(())
    } else {
        missing.sort();
        Err(SnapshotIncompleteError::new(missing))
    }
}

/// Validate that all non-.rs workspace files are declared as extra_inputs
///
/// This enforces the contract that files like templates, images, or other
/// assets used via include_str!(), include_bytes!(), etc. must be explicitly
/// declared in the build configuration.
///
/// # Arguments
///
/// * `observed_inputs` - The InputSet from parsing dep-info
/// * `declared_extra_inputs` - Set of workspace-relative paths explicitly declared
///
/// # Returns
///
/// Ok(()) if all non-.rs files are declared
/// Err(UndeclaredExtraInputsError) with undeclared files otherwise
///
/// # V1 Behavior
///
/// Currently, this validation is informational only. V2 will enforce the requirement.
pub fn validate_extra_inputs(
    observed_inputs: &InputSet,
    declared_extra_inputs: &HashSet<String>,
) -> Result<(), UndeclaredExtraInputsError> {
    let mut undeclared = Vec::new();

    for workspace_file in &observed_inputs.workspace_files {
        let path = &workspace_file.rel_path;

        // Check if this is a non-.rs file
        if !path.ends_with(".rs") && !path.ends_with("Cargo.toml") && !path.ends_with("Cargo.lock")
        {
            // Non-.rs workspace file - must be declared
            if !declared_extra_inputs.contains(path) {
                undeclared.push(path.clone());
            }
        }
    }

    if undeclared.is_empty() {
        Ok(())
    } else {
        undeclared.sort();
        // V1: Return error but caller may choose to warn instead of fail
        Err(UndeclaredExtraInputsError::new(undeclared))
    }
}

/// Validate that all external deps are either toolchain or explicitly allowed
///
/// This enforces hermetic builds: only files in workspace, toolchain, or
/// explicitly declared locations are permitted.
pub fn validate_external_deps(
    input_set: &InputSet,
    _toolchain_roots: &[Utf8PathBuf],
) -> Result<(), OutsideWorkspaceError> {
    // For now, we classify external deps optimistically during build_input_set_from_depinfo
    // Any path that wasn't workspace/toolchain/generated went into declared_external
    // In the future, we'd check here that declared_external paths were actually
    // pre-declared via contract, and reject if not.

    // V1: Accept all external deps but track them
    // V2 (future): Require explicit declaration
    if !input_set.declared_external.is_empty() {
        // Log/warn that external deps exist
        // For now, this is informational only
    }

    Ok(())
}

/// Build an InputSet from rustc dep-info output
///
/// Takes the parsed dependency paths from a dep-info file and classifies
/// them into the appropriate InputSet categories.
///
/// This is the authoritative record of what rustc actually read during
/// compilation - it's used for cache keys and dynamic graph expansion.
pub fn build_input_set_from_depinfo(
    dep_paths: &[Utf8PathBuf],
    workspace_root: &Utf8Path,
    toolchain_roots: &[Utf8PathBuf],
    generated_roots: &[Utf8PathBuf],
) -> InputSet {
    let mut input_set = InputSet::new();

    for path in dep_paths {
        match classify_path(path, workspace_root, toolchain_roots, generated_roots) {
            PathClassification::Workspace(rel) => {
                input_set.add_workspace_file(rel);
            }
            PathClassification::Generated(id) => {
                input_set.add_generated_file(id);
            }
            PathClassification::Toolchain(path) => {
                input_set.add_toolchain_file(path);
            }
            PathClassification::External(path) => {
                // External files may need to be declared via contract
                // For now, we just treat them as external inputs
                // In the future, validation could reject undeclared external deps
                input_set.add_declared_external(path);
            }
        }
    }

    input_set.normalize();
    input_set
}

/// Classify a dependency path based on known roots
///
/// Classification order matters: more specific roots should be checked first.
/// For example, generated roots (which may be under workspace) should be
/// checked before workspace root.
pub fn classify_path(
    path: &Utf8Path,
    workspace_root: &Utf8Path,
    toolchain_roots: &[Utf8PathBuf],
    generated_roots: &[Utf8PathBuf],
) -> PathClassification {
    // Try generated roots first (may be under workspace)
    for generated_root in generated_roots {
        if path.starts_with(generated_root) {
            // Extract some kind of ID from the path
            // For now, just use the relative path within the generated root
            if let Ok(stripped) = path.strip_prefix(generated_root) {
                return PathClassification::Generated(stripped.to_string());
            }
        }
    }

    // Try toolchain roots
    for toolchain_root in toolchain_roots {
        if path.starts_with(toolchain_root) {
            return PathClassification::Toolchain(path.to_string());
        }
    }

    // Try workspace (most common case, but checked after more specific roots)
    if let Ok(stripped) = path.strip_prefix(workspace_root) {
        return PathClassification::Workspace(stripped.to_string());
    }

    // Unknown/external
    PathClassification::External(path.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_snapshot_complete_all_present() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("src/mod.rs".to_string());

        let mut snapshot_files = HashSet::new();
        snapshot_files.insert("src/lib.rs".to_string());
        snapshot_files.insert("src/mod.rs".to_string());
        snapshot_files.insert("src/extra.rs".to_string()); // Extra files in snapshot are OK

        let result = validate_snapshot_complete(&input_set, &snapshot_files);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_snapshot_complete_missing_file() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("src/missing.rs".to_string());

        let mut snapshot_files = HashSet::new();
        snapshot_files.insert("src/lib.rs".to_string());

        let result = validate_snapshot_complete(&input_set, &snapshot_files);
        assert!(result.is_err());

        let err = result.unwrap_err();
        assert_eq!(err.missing_files, vec!["src/missing.rs"]);
    }

    #[test]
    fn test_validate_snapshot_complete_multiple_missing() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/a.rs".to_string());
        input_set.add_workspace_file("src/z.rs".to_string());
        input_set.add_workspace_file("src/m.rs".to_string());

        let mut snapshot_files = HashSet::new();
        snapshot_files.insert("src/a.rs".to_string());

        let result = validate_snapshot_complete(&input_set, &snapshot_files);
        assert!(result.is_err());

        let err = result.unwrap_err();
        // Should be sorted
        assert_eq!(err.missing_files, vec!["src/m.rs", "src/z.rs"]);
    }

    #[test]
    fn test_validate_snapshot_complete_empty() {
        let input_set = InputSet::new();
        let snapshot_files = HashSet::new();

        let result = validate_snapshot_complete(&input_set, &snapshot_files);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_extra_inputs_all_rs_files() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("src/mod.rs".to_string());

        let declared = HashSet::new(); // No extra inputs declared

        let result = validate_extra_inputs(&input_set, &declared);
        assert!(result.is_ok()); // .rs files don't need to be declared
    }

    #[test]
    fn test_validate_extra_inputs_with_declared() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("templates/index.html".to_string());

        let mut declared = HashSet::new();
        declared.insert("templates/index.html".to_string());

        let result = validate_extra_inputs(&input_set, &declared);
        assert!(result.is_ok());
    }

    #[test]
    fn test_validate_extra_inputs_undeclared() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("data/config.json".to_string());

        let declared = HashSet::new();

        let result = validate_extra_inputs(&input_set, &declared);
        assert!(result.is_err());

        let err = result.unwrap_err();
        assert_eq!(err.undeclared_files, vec!["data/config.json"]);
    }

    #[test]
    fn test_validate_extra_inputs_cargo_files_allowed() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("src/lib.rs".to_string());
        input_set.add_workspace_file("Cargo.toml".to_string());
        input_set.add_workspace_file("Cargo.lock".to_string());

        let declared = HashSet::new();

        let result = validate_extra_inputs(&input_set, &declared);
        assert!(result.is_ok()); // Cargo files don't need declaration
    }

    #[test]
    fn test_validate_extra_inputs_multiple_undeclared() {
        let mut input_set = InputSet::new();
        input_set.add_workspace_file("assets/logo.png".to_string());
        input_set.add_workspace_file("data/schema.sql".to_string());
        input_set.add_workspace_file("templates/base.html".to_string());

        let mut declared = HashSet::new();
        declared.insert("templates/base.html".to_string()); // Only one declared

        let result = validate_extra_inputs(&input_set, &declared);
        assert!(result.is_err());

        let err = result.unwrap_err();
        // Should be sorted
        assert_eq!(
            err.undeclared_files,
            vec!["assets/logo.png", "data/schema.sql"]
        );
    }

    #[test]
    fn test_input_set_normalize() {
        let mut set = InputSet::new();
        set.add_workspace_file("src/lib.rs".into());
        set.add_workspace_file("src/main.rs".into());
        set.add_workspace_file("src/lib.rs".into()); // duplicate

        set.normalize();

        assert_eq!(set.workspace_files.len(), 2);
        assert_eq!(set.workspace_files[0].rel_path, "src/lib.rs");
        assert_eq!(set.workspace_files[1].rel_path, "src/main.rs");
    }

    #[test]
    fn test_classify_workspace_file() {
        let workspace_root = Utf8Path::new("/project");
        let path = Utf8Path::new("/project/src/lib.rs");

        let classification = classify_path(path, workspace_root, &[], &[]);

        assert_eq!(
            classification,
            PathClassification::Workspace("src/lib.rs".into())
        );
    }

    #[test]
    fn test_classify_toolchain_file() {
        let workspace_root = Utf8Path::new("/project");
        let toolchain_roots = vec![Utf8PathBuf::from("/Users/user/.rustup")];
        let path = Utf8Path::new("/Users/user/.rustup/toolchains/stable/lib/rustlib/src/rust/library/std/src/lib.rs");

        let classification = classify_path(path, workspace_root, &toolchain_roots, &[]);

        assert!(matches!(
            classification,
            PathClassification::Toolchain(_)
        ));
    }

    #[test]
    fn test_classify_external_file() {
        let workspace_root = Utf8Path::new("/project");
        let path = Utf8Path::new("/some/other/path/file.rs");

        let classification = classify_path(path, workspace_root, &[], &[]);

        assert!(matches!(classification, PathClassification::External(_)));
    }

    #[test]
    fn test_classify_generated_file() {
        let workspace_root = Utf8Path::new("/project");
        let generated_roots = vec![Utf8PathBuf::from("/project/target/generated")];
        let path = Utf8Path::new("/project/target/generated/build/foo-abc123/out/bindings.rs");

        let classification = classify_path(path, workspace_root, &[], &generated_roots);

        assert!(matches!(classification, PathClassification::Generated(_)));
    }
}
