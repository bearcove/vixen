//! Depfile parsing for C/C++ header discovery
//!
//! Parses Make-style depfiles generated by `-MMD -MF` flags.
//! These files list the headers a translation unit depends on.
//!
//! Format:
//! ```text
//! target.o: source.c header1.h header2.h \
//!   subdir/header3.h
//! ```

use camino::{Utf8Path, Utf8PathBuf};
use thiserror::Error;

/// Errors during depfile parsing
#[derive(Debug, Error)]
pub enum DepfileError {
    #[error("failed to read depfile: {0}")]
    IoError(#[from] std::io::Error),

    #[error("invalid depfile format: {0}")]
    ParseError(String),

    #[error("dependency escapes workspace: {path}")]
    EscapesWorkspace { path: String },
}

/// Parsed depfile contents
#[derive(Debug, Clone)]
pub struct ParsedDepfile {
    /// The target (usually the .o file)
    pub target: Utf8PathBuf,
    /// All dependencies (source file + headers)
    pub deps: Vec<Utf8PathBuf>,
}

impl ParsedDepfile {
    /// Get just the header dependencies (excluding the primary source file)
    pub fn headers(&self, source: &Utf8Path) -> Vec<&Utf8Path> {
        self.deps
            .iter()
            .filter(|p| p.as_path() != source)
            .map(|p| p.as_path())
            .collect()
    }
}

/// Parse a depfile from its contents
///
/// The depfile format is:
/// ```text
/// target: dep1 dep2 \
///   dep3 dep4
/// ```
///
/// Backslash-newline continues the line. Spaces separate dependencies.
/// Paths with spaces are escaped with backslash.
pub fn parse_depfile(contents: &str) -> Result<ParsedDepfile, DepfileError> {
    // Join continuation lines
    let contents = contents.replace("\\\n", " ").replace("\\\r\n", " ");

    // Find the colon separating target from deps
    let colon_pos = contents
        .find(':')
        .ok_or_else(|| DepfileError::ParseError("no colon found".into()))?;

    let target = contents[..colon_pos].trim();
    let deps_str = contents[colon_pos + 1..].trim();

    // Parse the target
    let target = Utf8PathBuf::from(unescape_path(target));

    // Parse dependencies - split on whitespace, handling escaped spaces
    let deps = parse_deps(deps_str)?;

    Ok(ParsedDepfile { target, deps })
}

/// Parse a depfile from a file path
pub fn parse_depfile_path(path: &Utf8Path) -> Result<ParsedDepfile, DepfileError> {
    let contents = std::fs::read_to_string(path)?;
    parse_depfile(&contents)
}

/// Parse dependencies from the right side of the colon
fn parse_deps(s: &str) -> Result<Vec<Utf8PathBuf>, DepfileError> {
    let mut deps = Vec::new();
    let mut current = String::new();
    let mut chars = s.chars().peekable();

    while let Some(c) = chars.next() {
        match c {
            '\\' => {
                // Escape sequence
                if let Some(&next) = chars.peek() {
                    match next {
                        ' ' | '#' | '\\' => {
                            // Escaped special char
                            current.push(chars.next().unwrap());
                        }
                        '\n' | '\r' => {
                            // Line continuation (already handled, but just in case)
                            chars.next();
                            if chars.peek() == Some(&'\n') {
                                chars.next();
                            }
                        }
                        _ => {
                            // Not a recognized escape, keep the backslash
                            current.push('\\');
                        }
                    }
                } else {
                    current.push('\\');
                }
            }
            ' ' | '\t' | '\n' | '\r' => {
                // Whitespace ends the current path
                if !current.is_empty() {
                    deps.push(Utf8PathBuf::from(&current));
                    current.clear();
                }
            }
            _ => {
                current.push(c);
            }
        }
    }

    // Don't forget the last path
    if !current.is_empty() {
        deps.push(Utf8PathBuf::from(&current));
    }

    Ok(deps)
}

/// Unescape a path (remove backslash escapes)
fn unescape_path(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut chars = s.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '\\'
            && let Some(&next) = chars.peek()
            && (next == ' ' || next == '#' || next == '\\')
        {
            result.push(chars.next().unwrap());
            continue;
        }
        result.push(c);
    }

    result
}

/// Canonicalize dependencies to workspace-relative paths
///
/// This function:
/// 1. Resolves paths relative to a base directory
/// 2. Converts to workspace-relative paths
/// 3. Rejects any paths that escape the workspace
/// 4. Sorts and deduplicates for determinism
pub fn canonicalize_deps(
    deps: &[Utf8PathBuf],
    base_dir: &Utf8Path,
    workspace_root: &Utf8Path,
) -> Result<Vec<Utf8PathBuf>, DepfileError> {
    let mut canonical = Vec::with_capacity(deps.len());

    for dep in deps {
        // Make absolute if relative
        let abs_path = if dep.is_relative() {
            base_dir.join(dep)
        } else {
            dep.clone()
        };

        // Normalize the path (resolve . and ..)
        let normalized = normalize_path(&abs_path);

        // Check if it's within the workspace
        if let Ok(rel) = normalized.strip_prefix(workspace_root) {
            canonical.push(Utf8PathBuf::from(rel));
        } else {
            // Path escapes workspace - this could be a system header
            // For now, we skip system headers (they're part of the toolchain)
            // In the future, we might want to track them separately
            continue;
        }
    }

    // Sort and deduplicate for determinism
    canonical.sort();
    canonical.dedup();

    Ok(canonical)
}

/// Normalize a path by resolving . and .. components
fn normalize_path(path: &Utf8Path) -> Utf8PathBuf {
    let mut components = Vec::new();

    for component in path.components() {
        match component {
            camino::Utf8Component::CurDir => {
                // Skip .
            }
            camino::Utf8Component::ParentDir => {
                // Pop if we can, otherwise keep the ..
                if !components.is_empty()
                    && components.last() != Some(&camino::Utf8Component::ParentDir)
                {
                    components.pop();
                } else {
                    components.push(component);
                }
            }
            _ => {
                components.push(component);
            }
        }
    }

    components.iter().collect()
}

/// Hash a sorted list of dependency paths for cache key computation
pub fn hash_deps(deps: &[Utf8PathBuf]) -> vx_oort_proto::Blake3Hash {
    let mut hasher = blake3::Hasher::new();

    for dep in deps {
        hasher.update(dep.as_str().as_bytes());
        hasher.update(b"\0");
    }

    vx_oort_proto::Blake3Hash(*hasher.finalize().as_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_simple_depfile() {
        let contents = "main.o: main.c header.h";
        let parsed = parse_depfile(contents).unwrap();

        assert_eq!(parsed.target, Utf8PathBuf::from("main.o"));
        assert_eq!(parsed.deps.len(), 2);
        assert_eq!(parsed.deps[0], Utf8PathBuf::from("main.c"));
        assert_eq!(parsed.deps[1], Utf8PathBuf::from("header.h"));
    }

    #[test]
    fn parse_multiline_depfile() {
        let contents = "main.o: main.c \\\n  header1.h \\\n  header2.h";
        let parsed = parse_depfile(contents).unwrap();

        assert_eq!(parsed.target, Utf8PathBuf::from("main.o"));
        assert_eq!(parsed.deps.len(), 3);
        assert_eq!(parsed.deps[0], Utf8PathBuf::from("main.c"));
        assert_eq!(parsed.deps[1], Utf8PathBuf::from("header1.h"));
        assert_eq!(parsed.deps[2], Utf8PathBuf::from("header2.h"));
    }

    #[test]
    fn parse_escaped_spaces() {
        let contents = r"main.o: my\ file.c header.h";
        let parsed = parse_depfile(contents).unwrap();

        assert_eq!(parsed.deps[0], Utf8PathBuf::from("my file.c"));
    }

    #[test]
    fn parse_absolute_paths() {
        let contents = "main.o: /home/user/project/main.c /usr/include/stdio.h";
        let parsed = parse_depfile(contents).unwrap();

        assert_eq!(
            parsed.deps[0],
            Utf8PathBuf::from("/home/user/project/main.c")
        );
        assert_eq!(parsed.deps[1], Utf8PathBuf::from("/usr/include/stdio.h"));
    }

    #[test]
    fn canonicalize_filters_system_headers() {
        let deps = vec![
            Utf8PathBuf::from("src/main.c"),
            Utf8PathBuf::from("include/header.h"),
            Utf8PathBuf::from("/usr/include/stdio.h"),
        ];

        let workspace = Utf8PathBuf::from("/home/user/project");
        let base_dir = workspace.clone();

        let canonical = canonicalize_deps(&deps, &base_dir, &workspace).unwrap();

        // System header should be filtered out
        assert_eq!(canonical.len(), 2);
        assert!(canonical.contains(&Utf8PathBuf::from("src/main.c")));
        assert!(canonical.contains(&Utf8PathBuf::from("include/header.h")));
    }

    #[test]
    fn canonicalize_resolves_relative_paths() {
        let deps = vec![
            Utf8PathBuf::from("../include/header.h"),
            Utf8PathBuf::from("./main.c"),
        ];

        let workspace = Utf8PathBuf::from("/home/user/project");
        let base_dir = Utf8PathBuf::from("/home/user/project/src");

        let canonical = canonicalize_deps(&deps, &base_dir, &workspace).unwrap();

        assert!(canonical.contains(&Utf8PathBuf::from("include/header.h")));
        assert!(canonical.contains(&Utf8PathBuf::from("src/main.c")));
    }

    #[test]
    fn headers_excludes_source() {
        let parsed = ParsedDepfile {
            target: Utf8PathBuf::from("main.o"),
            deps: vec![
                Utf8PathBuf::from("src/main.c"),
                Utf8PathBuf::from("include/header.h"),
            ],
        };

        let source = Utf8Path::new("src/main.c");
        let headers = parsed.headers(source);

        assert_eq!(headers.len(), 1);
        assert_eq!(headers[0], Utf8Path::new("include/header.h"));
    }

    #[test]
    fn hash_deps_deterministic() {
        let deps1 = vec![
            Utf8PathBuf::from("a.h"),
            Utf8PathBuf::from("b.h"),
            Utf8PathBuf::from("c.h"),
        ];

        let deps2 = vec![
            Utf8PathBuf::from("a.h"),
            Utf8PathBuf::from("b.h"),
            Utf8PathBuf::from("c.h"),
        ];

        assert_eq!(hash_deps(&deps1), hash_deps(&deps2));

        // Different order should give different hash (caller must sort first)
        let deps3 = vec![
            Utf8PathBuf::from("c.h"),
            Utf8PathBuf::from("b.h"),
            Utf8PathBuf::from("a.h"),
        ];

        assert_ne!(hash_deps(&deps1), hash_deps(&deps3));
    }
}
